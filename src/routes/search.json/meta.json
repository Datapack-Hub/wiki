[{"title":"MissingNo.","content":"\n\tError: {$page.status} | Datapack Hub\nError {$page.status}: {$page.error.message}\nThere was an error when loading this page. Maybe it doesn't exist?\n\nIf you think this is an error, please report it in our discord.","tags":[],"versions":"latest","url":"/+"},{"title":"Commands","content":"\nThis page is validated and up to date with Minecraft Java: 1.21\n\nCommands\nCommands are the basic building blocks of most datapacks. Each command is a simple instruction which can tell the game to do something. Most datapacks are made primarily of functions - functions are just lists of commands ran in order.\n\nCommand Syntax\nMost commands follow this basic syntax:\ncommand ...\ncommand would refer to the name of the command, and ... would be the arguments that come after the command, changing how it runs.\n\nMinecraft (and this wiki) use these for showing command syntax, to make it easier for you to understand:\n\nVariable | Meaning\n|---------\n `` | An argument.\n [entry] | An optional entry.\n [entryA│entryB│entryC] | Pick one of these. This is optional.\n (entryA│entryB│entryC) | Pick one of these. This is required\n ... | Some syntax is left out, you can find more about the command on its dedicated page","tags":[],"versions":"latest","url":"/wiki/commands/about/"},{"title":"Target Selectors","content":"\nThis page is validated and up to date with Minecraft Java: 1.21\n\nItem Components\nItem components are data structures which can be applied to items in Minecraft to give them special attributes, such as a name, lore, being able to be eaten, etc. Each item has specific item components by default - for example, all food items will have the minecraft:food component, which makes the item edible.\n\nA command such as /give or /item can be used to create an item which has additional item components, or remove item components from any item.","tags":[],"versions":"latest","url":"/wiki/commands/item_components/"},{"title":"Coordinates","content":"\nThis page is validated and up to date with Minecraft Java: 1.21\n\nCoordinates\nCoordinates in Minecraft are represented by an x, y, and z value. They are used to represent positions of entities, blocks, particles, sounds and more. In commands, they are represented as simply x y z, where x, y, and z are decimal numbers representing the coordinates on each axis.\n\nBlock coordinates are locked to the grid and are unique - there can only be one block per set of coordinates. Block coordinates are whole numbers, for example you can have a block at 123 86 94 but not 123.7 86.2 94.6. Entities are not locked to the grid - they can be at decimal positions (and usually are).\n\nx.0 y.0 z.0 represents the bottom left corner of a block, not the centre. The centre of a block would be represented by the coordinates x.5 y.5 z.5.\n\nEvery command and function in Minecraft is always executed at a position. This is usually the world spawn. You can change this using the commands \"execute at\" or \"execute positioned\".\n\nExamples\n/setblock 123 86 94 minecraft:pink_concrete:\nIn this setblock command, we tell the game to put a pink concrete block at the coordinates 123 86 94.\n/tp @s 66.2 98 45.7:\nThis command would teleport the current entity to the exact coordinates 66.2 98 45.7\n\nRelative Coordinates\nUsing the symbols ~ and ^, we can reference coordinates relative to the current coordinates (for example, you can get the posiiton 7 blocks above the current position).\n\n represents the current position on any axis. For example, 12  76 would teleport me to x=12 z=76 but keep y as the current position. The coordinates   ~ would represent the position of the command - this is useful to do something at the current position such as placing a block or summoning an entity.\n\nThe  symbol can be followed by a number to include an offset to the current position. For example,  12  would represent the current postion offsetted by 10 blocks on the y-axis (or in simpler terms: the position 10 blocks above the current position). This can also be a negative number.\n\nSimilarly ^ represents a relative position, taking into account the current rotation too. The most common use for this is to get a position in front of the direction of rotation. For example, you can use ^ ^ ^5 to get the position 5 blocks in front of the current position in whatever direction the command or entity is rotated.","tags":[],"versions":"latest","url":"/wiki/commands/coordinates/"},{"title":"MissingNo.","content":"","tags":[],"versions":"latest","url":"/wiki/commands/namespaces/"},{"title":"Target Selectors","content":"\nThis page is validated and up to date with Minecraft Java: 1.21\n\nTarget Selectors\nTarget Selectors are used as an argument in commands to select entities and players in the world. We use target selectors to find players or mobs and do things to them.\n\nExample: tellraw @a[distance=..10] \"You're within 10 blocks of me\". The target selector is @a[distance=..10], and tells the game to only send the message to players within 10 blocks.\n\nBase target selectors\nIn Java Edition, there are 5 base target selectors:\n\n@e**: @e selects all entities, no matter what type or where they are.\n@a*: @a selects all players. *This is equivalent to @e[type=player]\n@s**: @s selects the current entity who is running the command or function.\n@p*: @p selects the nearest player to the position of execution. *This is equivalent to @e[type=player,limit=1,sort=nearest]\n@r*: @r selects a random player. *This is equivalent to @e[type=player,limit=1,sort=random]\n@n*: @n selects the nearest entity from the command's execution. *This is equivalent to @e[sort=nearest,limit=1] [1.21+]\n\n@e only selects entities in a loaded chunk. If an entity exists but is not currently being loaded, it will not select that entity.\n\nAdditional arguments\nTarget selectors can (and usually are) followed by additional arguments to filter the selection even more to only find the entities that you want. Target selector arguments are contained within square brackets after the base selector (@e[...]) and are written as [:,=,...]\n\nExample: In our previous example (@a[distance=..10]), we use the argument distance=..10 to specify that we only want to target entities which are less than 10 blocks away.\n\nMost target selectors can be inverted by using =! meaning it will only select entities who do not match the argument. (E.g. @e[type=!minecraft:creeper] will select every entity that is NOT a creeper)\n\ntype argument\nThe type= argument will filter the selection to only include entities of a certain type, or those in an entity_type tag.\n\n` must be a valid entity ID or entity_type tag ID. This argument can only be used with @e or @s`.\n\nExamples:\n@e[type=minecraft:pig]: Selects all pigs\n@e[type=#minecraft:aquatic]: Selects all aquatic animals\n\nname argument\nThe name= argument will filter the selection to only include entities who have a specific name.\n\n`` is a string (it cannot be a JSON text component).\n\nExamples:\n@e[name=Aron]: Selects all entities named Aron\n@e[name=\"Aron Aronson\"]: Selects entities named Aron Aaronson\n\ndistance argument\nThe distance= argument will filter the selection to only include entities who are within a distance range.\n\n` can either be a value (such as 7) or a range (such as ..8 or 21..`)\n\nExamples:\n@e[distance=6]: Selects all entities which are exactly 6 blocks away from the execution position.\n@e[distance=..20]: Selects all entities within 20 blocks of the execution position.\n@e[distance=3..]: Selects all entities that are more than 3 blocks away from the execution position.\n@e[distance=12..15]: Selects all entities between 12 and 15 (inclusive) blocks from the execution position.\n\nnbt argument\nThe nbt= argument will filter the selection to only include entities which have or do not have specific NBT data.\n\n`` is an NBT compound. The entity must match everything within the compound.\n\nExamples:\n@a[nbt={SelectedItem:{id:\"minecraft:stone\"}}]: Selects all players who are holding stone\n@e[type=minecraft:arrow,nbt={inGround:1b}]: Selects all arrow entities who are in a block.\n\nsort and limit arguments\nThe sort=,limit= will limit the amount of possible entities it will select and will select entities based on the priority defined in ``.\n\n`` can be one of the following:\narbitrary: does not sort in any guaranteed order\nnearest: sort in increasing order of distance\nfurthest: sort in decreasing order of distance\nrandom: sort randomly (default type for @r)\n\n`` can be any integer.\n\nExamples:\n@e[limit=1,sort=nearest]: Selects the nearest entity to the position of execution\n@e[limit=5,sort=furthest]: Selects the furthest 5 entities from the position of execution.\n@e[limit=7,sort=random,type=minecraft:cow]: Selects 7 random cows..\n\nx/y/z arguments\nThe x/y/z= arguments do not directly change the selection, but are used alongside other arguments to specify a starting position to work from.\n\nThis argument(s) will affect the arguments distance, dx/dy/dz and sort/limit.\n\nExamples:\n@e[x=10,y=9,z=-5,distance=..5]: Selects all entities less than 5 blocks away from the position X=10/Y=9/Z=-5\n\ndx/dy/dz arguments\nThe dx/dy/dz arguments will create a cuboid that is at least 1x1x1 blocks big and each value above 0 will increase the size of the cuboid in that direction by a full block.\n\nAny entity fully or partially inside the cuboid will be selected.\n\nYou can mix and match dx, dz, and dz however you want. To create the cuboid at least 1 of the three has to be there.\n\nThe generated cuboid does not snap to the block grid\nThe base cuboid that gets generated with dx/dz/dz=0 will always stretch from the command origin to positive x/y/z\n\nExamples:\n@e[x=10,y=13,z=87,dx=10,dy=20,dz=5]: Selects any entities if any part of their hitbox is within the cuboid w=10,h=20,l=5 starting from the position x=10,y=13,z-87\n@e[x=7,y=3,z=9,dx=0,dy=0,dz=0]: Selects any entities if their hitbox contains the point x=7,y=3,z=9\n\ntag argument\nThe tag= argument will select entities which have the specified tag. `` is any tag string (no spaces).\n\nEntities do not naturally have tags - these are separate from entity_type tags such as that used in the type argument. Instead, these select entities based on the tags added with the /tag command or Tags[] NBT.\n\nExamples:\n@a[tag=CustomTag]: Selects all players with the tag CustomTag\n@e[tag=!ignore]: Selects all entities which do not have the ignore tag.\n\nteam argument\nThe team= argument will select entities which are in a specific team. Since entities can only be in one team at a time, you cannot use team= more than once, however you can duplicate negated team arguments (team=!).\n\n`` is any tag string (no spaces).\n\nExamples:\n@a[team=red]: Selects all players in the red team\n@e[team=Bears]: Selects all entities in the Bears team\n@e[team=!blue]: Selects all entities which are not in the blue team\n\nscores argument\nThe scores={=,...} argument will select entities based on their value on a scoreboard.\n\n` is a scoreboard objective which must exist already. ` can be either an integer or a range.\n\nExamples:\n@e[scores={foo=10}]: Selects all entities with a score of exactly 10 on the foo scoreboard.\n@e[scores={foo=5,bar=7}]: Selects all entities with a score of exactly 5 on the foo scoreboard and exactly 7 on the bar scoreboard.\n@e[scores={foo=8..}]: Selects all entities with a score of 8 or more on the foo scoreboard.\n\npredicate argument\nThe predicate= argument will select players based on whether they pass a predicate check. `` is a predicate ID.\n\nExamples:\n@e[predicate=namespace:my_predicate]: Selects all entities who pass the predicate in /data/namespace/predicates/my_predicate.- - @e[predicate=!namespace:another_predicate]: Selects all entities who fail the predicate in /data/namespace/predicates/another_predicate.json`\n\ngamemode argument\nThe gamemode=(survival|creative|adventure|spectator) argument will select players who are in a specific game mode.\n\nExamples:\n@a[gamemode=creative]: Selects all players in creative mode\n\nadvancements argument\nThe advancements={=(true/false)} argument will select players based on whether they've unlocked an advancement. `` is an advancement ID.\n\nExamples:\n@a[advancements={minecraft:story/follow_ender_eye=true}]: Selects all players who have unlocked the follow_ender_eye advancement.\n@a[advancements={minecraft:story/follow_ender_eye=false}]: Selects all players who have not unlocked the follow_ender_eye advancement.\n\nadvancements argument\nThe advancements={=(true/false)} argument will select players based on whether they've unlocked an advancement. `` is an advancement ID.\n\nExamples:\n@a[advancements={minecraft:story/follow_ender_eye=true}]: Selects all players who have unlocked the follow_ender_eye advancement.\n@a[advancements={minecraft:story/follow_ender_eye=false}]: Selects all players who have not unlocked the follow_ender_eye advancement.\n\nlevel argument\nThe level= argument selects players based on their current XP level (not amount of points).\n\n`` can be an integer or range.\n\nExamples:\n@a[level=10]: Selects all players who have an XP level of exactly 10.\n@a[level=4..]: Selects all players who have an XP level of 4 or more.\n\nTODO x_rotation and y_rotation\n","tags":[],"versions":"latest","url":"/wiki/commands/target_selectors/"},{"title":"Getting Started","content":"\nThis page is validated and up to date with Minecraft Java: 1.21\n\nSyntax\n\nVariable | Meaning\n|---------\n `` | An argument.\n [entry] | An optional entry.\n [entryA│entryB│entryC] | Pick one of these. This is optional.\n (entryA│entryB│entryC) | Pick one of these. This is required\n ... | Some syntax is left out, you can find more about the command on its dedicated page\n\nList of all commands\nPermission level 2+\nThese commands require a permission level same or bigger than 2 to run them.\n/advancement grant|revoke  everything|only|from|through|until (|) - Gives, removes or checks player advancements\n/attribute   get|base|modifier ... - Can change or read attributes\n/bossbar list|add|remove|set|get [] ... - Changes and creates bossbars\n/clear [] [] [] - Clears items from the players inventory\n/clone   ... OR /clone from    ... - Copies blocks in an area from one place to another\n/damage   [] [at ]|[by ] [from ] - Damages selected entities\n/data get|merge|modify|remove ... - Changes block entity or entity NBT data (See more here: /data)\n   Data get: `/data get (block |entity |storage ) [","tags":[],"versions":"latest","url":"/wiki/command/all/"},{"title":"/execute","content":"\n This page is up to date and validated for the Minecraft version: 1.20.6\n\n/execute command\nThe execute command is used to execute other commands conditionally, or in a different context. The execute command is made up of multiple subcommands, which can be chained repeatedly and in any order to modify context in various ways.\n\nEach subcommand has its own syntax, and most allow/require another subcommand to follow.\n\nContext\nEvery command is executed in a context. Various execute subcommands can modify the context in which other commands are run.\nThe context includes:\nPosition: The position at which the command is executed (the origin of relative coordinates)\nAnchor: Either eyes or feet. Specifies the origin of local coordinates to either the eyes or feet of an entity.\nExecutor: The entity executing the command (which entity the @s selector refers to)\nRotation: The rotation of the command\nDimension: The dimension in which the command is executed\n\nForking\nSome commands cause a fork. That is, the following chain of subcommands get executed more than once. When a command is forked, it executes the fork as a whole, then proceeds to the next fork.\n\nFor example, if there are two markers A and B, and the following command is run: execute as @e[type=marker] run function example\nAnd the example function contained the following commands:\n\nsay first command\nsay second command\n\nThe chat output would look like this:\n\n[A] first command\n[A] second command\n[B] first command\n[B] second command\n\nSubcommands\n\nIn this documentation, ... represents another required subcommand, and [...] denotes that another subcommand is optional.\n\nexecute align  ...\nThe align  subcommand aligns the executing position to the specified axes (rounding down coordinates to integers). ` can be any subset of xyz`, in any order.\n\nExamples:\nexecute align xz ...\nexecute align yxz ...\n\nexecute anchored (eyes|feet) ...\nChanges the execution anchor to the eyes or feet of the entity.\n\nExamples:\nexecute anchored eyes ...\n\nexecute as  ...\nChanges the executor of the following subcommand to `` (Does not modify any other context such as location).\nIf `` refers to multiple entities, the following subcommand gets executed once for each referenced entity, with that entity as the executor.\nIf `` refers to no entities, the execute chain terminates and no further subcommands are run.\n\nExamples:\nexecute as @a[distance=10..] ...\nexecute as @e[type=pig] ...\n\nexecute at  ...\nChanges the position and rotation of the following subcommand to that of `` (Executor remains the same).\nForking rules apply the same as execute as.\n\nExamples:\nexecute at @s ...\nexecute at @p ...\n\nexecute facing  ...\nChanges the rotation of the following subcommand to face ``.\n` can either be a set of coordinates, or entity  (eyes|feet)`, which targets the eyes or feet of the given entity.\n\nExamples:\nexecute facing 0 0 0 ...\nexecute facing entity @e[type=marker,limit=1] feet\n\nexecute in  ...\nChanges the dimension of the following subcommand to ``.\nApplies dimension scaling, meaning coordinates are divided by 8 when transferring from the overworld to the nether.\n\nExamples\nexecute in minecraft:nether ...\n\nexecute on  ...\nChanges executor to other entities based on their relation with the current executor. Same forking rules apply as execute as.\nPossible values for `` are:\nattacker - The most recent entity to damage the current entity in the last 5 seconds.\ncontroller - The entity which is riding and in control of the current entity.\nleasher - The entity holding the the current entity on a lead.\norigin - The entity the current entity originated from, such as the player that shot an arrow.\npassengers - All entities riding the current entity (not including entities riding the passengers).\ntarget - The entity the current entity is trying to attack (angry at).\nvehicle - The entity that the current entity is riding.\n\nExamples\nexecute on passengers ...\nexecute on target ...\n\nexecute positioned  ...\nChanges the position (but not rotation) of the following subcommand to ``. Also resets anchor.\n` can be a set of coordinates, as , or over `.\npositioned as  ... is equivalent to at  ..., except that it doesn't change rotation or dimension.\npositioned over  sets the y coordinate of the position to be one above the specified heightmap.\n\nExamples:\nexecute position  0 -10 ...\nexecute positioned as @s ...\nexecute over world_surface ...\n\nexecute rotated  ...\nChanges the rotation of the following subcommand to ``.\n` can either be rotation coordinates, or as , which changes the rotation to that of the specified entity. For rotated as , forking rules apply the same as as entity`.\n\nExamples:\nexecute rotated ~10 0 ...\nexecute rotated as @e[tag=rotate] ...\n\nexecute summon  ...\nSummons the specified entity at the current position, and executes the following subcommand as that entity.\nNote: You cannot specify NBT data for the summoned entity.\n\nExamples:\nexecute summon iron_golem ...\nexecute summon marker ...\n\nexecute run \nRuns the specified command with the current context. Takes no further subcommands.\n\nThis is useless by itself, and should always be preceded by other subcommands.\n\nExamples:\nexecute run say hi\nexecute at @e[type=sheep] run setblock   ~ stone\n\nexecute store (result|success)  ...\nStores an integer value somewhere. If storing result, this numeric value is taken from the output of the final subcommand (Either a run subcommand or a condition). If storing success, the value is either 1 if the final subcommand succeeds (condition passes or command successfully performs its function), or 0 otherwise.\n\ntarget can be one of the following:\n`block","tags":[],"versions":"latest","url":"/wiki/command/execute/"},{"title":"/function","content":"\n This page is up to date and validated for the Minecraft version: 1.21\n\n/function command\nThis command runs any .mcfunction file when called. You can also pass in a NBT compound or NBT source path if the function is a macro function. All functions are run independently and one after another - for example, if you run function1 and then function2, then function2 will only run once function1 has finished.\n\nSyntax\nfunction :**: Runs the .mcfunction file at data//function/\nfunction : {key:value}**: Runs the .mcfunction file at data//function/, and uses the {key:value} if the function is a macro function.\n`function : with (block |entity |storage )","tags":[],"versions":"latest","url":"/wiki/command/function/"},{"title":"Tags","content":"\nThis page is validated and up to date with Minecraft Java: 1.21\n\nTags\nRegistry tags, not to be confused with entity tags, are essentially lists of groups such as blocks, items, entity types, etc. They use JSON format and are located in the data//tags/ folder.\n\nSpecial tags\nMinecraft uses some tags internally for certain behaviours. These tags are located in the minecraft namespace. For example:\nany functions in the #minecraft:load function tag will be automatically run when a datapack is loaded\nthe #minecraft:minable/pickaxe block tag lists blocks which are mined faster using a pickaxe.\n\nIn many cases, modifying these special tags allows you to configure certain aspects of how Minecraft behaves.\n\nRegistries\nTags group various types in a specific registry (category).\n\nThis list shows all of the possible registry types, as well as the path their tags should be put in.\nItems (/tags/item)\nBlocks (/tags/block)\nEntity types (/tags/entity_type)\nFunctions (/tags/function)\nFluids (/tags/fluid)\nGame Events (/tags/game_event)\nChat Types (/tags/chat_type)\nDamage Types (/tags/damage_type)\nBanner patterns (/tags/banner_pattern)\nCat variants (/tags/cat_variant)\nEnchantments (/tags/enchantment)\nGoat horns (/tags/instrument)\nPaintings (/tags/painting_variant)\nEntity POI (/tags/point_of_interest_type)\nBiome (/tags/worldgen/biome)\nFlat world preset (/tags/worldgen/flat_level_generator_preset)\nStructures (/tags/worldgen/structure)\nWorld preset (/tags/worldgen/world_preset)\n\nJSON format\nTags have a very simple format, with two fields.\n\nreplace\nreplace is a boolean field which decides whether the tag should replace other tags with the same path, or merge with them. For example, if \"replace\": true is added to the tick.json function tag, only the tick functions in that datapack would load, as it would replace all other defined tick tags. If replace is false, it will merge with any values in tick.json within other packs.\nreplace is an optional field, and if not specified will default to false.\n\nvalues\nValues (values) is an array containing everything to group under this tag. Each element is either a string or an object containing an id field and a required field (object example {\"required\": false, \"id\":\"minecraft:stick\"} ). The plain string and the id field contain either the ID of the entry (such as minecraft:diamond_block), or the ID of another tag, beginning with a # (such as #minecraft:logs). The required field in the object is a boolean (true or false) which defines if this entry can be ignored if the id cannot be found.\n\nExample\nHere is an example tag, located in data//tags/item/wood.json.\n\n#minecraft:logs and #minecraft:planks are two item tags provided by Minecraft.\n\n\n{\n  \"replace\": true,\n  \"values\": [\n    \"#minecraft:logs\",\n    \"#minecraft:planks\",\n    \"minecraft:chest\",\n    \"minecraft:stick\"\n  ]\n}\n","tags":[],"versions":"latest","url":"/wiki/files/tags/"},{"title":"Functions","content":"\nThis page is validated and up to date with Minecraft Java: 1.21\n\nFunctions\nFunctions are files essentially containing a list of Minecraft commands. Function files end in .mcfunction, and are located in the data//function folder. Functions can be called (ran) using the function command. (See /function for more information)\n\nThe function folder can contain sub-folders for organisation. This changes their reference accordingly - for example, a function located at data//function/sub_folder/my_func.mcfunction would be called using function :sub_folder/my_func.\n\nWhen a function is run, the commands within it are executed in order. If the return command is run, the function stops executing immediately and any commands after the return are ignored.\n\nAny line in a function which starts with a # is a comment, and the game ignores it. Any other line is interpreted as a command\n\nExample\nThis function will give every player an apple, then tell them to enjoy the apple.\nGive a player the apple\ngive @a minecraft:apple\n\nTell them to enjoy the apple\nsay Enjoy the apple!\n\nMacro functions\nMacros can dynamically change part of a function by inserting NBT into it. Any function can define a macro within it. A macro is a command beginning with $. Macros can use a special syntax: $(). This will substitute for any value provided as `` when run.\n\nThe /function command can specify a NBT compound to use as the macro values. In traditional programming, this is best represented as someFunction(foo, bar)\n\nExample\nIn this example, we write a function that gives the player a number of diamonds using a macro.\ndata/example/function/macro.mcfunction\n\nWhen called, $(count) will be replaced with some number, producing a valid command\n$give @s diamond $(count)\n\ndata/example/function/give.mcfunction\nfunction example:macro {count: 7}\n\nThis also works\ndata modify storage example:storage count set value 12\nfunction example:macro with storage example:storage\n","tags":[],"versions":"latest","url":"/wiki/files/functions/"},{"title":"Home","content":"\nSNBT Format\nSNBT (Stringified Named Binary Tags) format is a JSON-like tree structure used in datapack development to manipulate the NBT data of an entity. SNBT is a human-readable version of NBT (Named Binary Tags), which is a format used by Minecraft to store data. NBT is used to store data about entities, items, blocks, structures, game saves, and more.\n\nSNBT consists of key/value pairs, which are represented as key:value. These are contained with compounds, marked with curly brackets ({}). Compounds can contain multiple key/value pairs, which are separated with commas, like so: key:value,key:value,key:value\n\nAn example SNBT structure looks like: {name:\"Silabear\",age:102,friends:[\"Flynecraft\",\"Aandeel\",\"Cobblestone\"],socials:{discord:\"silabear\",twitch:\"silabearr\"}}\n\nData Types\nSNBT has a few data types you can use to represent different types of data, including whole numbers, decimal numbers, string, text, booleans, and more.\n\nStrings\nStrings can store any text value, or more technically, any sequence of unicode characters.\n\nFormat: Strings are stored within either double or single quotes. For strings containing standard characters (A-Z, a-z, 0-9, -,_,+,.), the quotes are optional, but recommended. `\"","tags":[],"versions":"latest","url":"/wiki/nbt/snbt/"},{"title":"Player ID System","content":"\nGive each player a unique ID\nCreate a scoreboard in a load function that runs on /reload\nnamespace:load\nscoreboard objectives add playerid dummy\nCreate a function to assign a unique id to the player\nnamespace:assign_id\nscoreboard players add .global playerid 1\nscoreboard players operation @s playerid = .global playerid\nCreate a tick advancement to assign an id to a player when they first join\n{\n  \"criteria\": { \"requirement\": { \"trigger\": \"minecraft:tick\" }},\n  \"rewards\": { \"function\": \"namespace:assign_id\" }\n}\nCheck if an entity has the same ID as the player\nCreate a predicate that compares the id\n// namespace:match_id\n{ \"condition\": \"minecraft:entity_scores\", \"entity\": \"this\", \"scores\": {\n  \"playerid\": {\n    \"min\": { \"type\": \"minecraft:score\", \"target\": { \"type\": \"minecraft:fixed\", \"name\": \"#this\" }, \"score\": \"playerid\" },\n    \"max\": { \"type\": \"minecraft:score\", \"target\": { \"type\": \"minecraft:fixed\", \"name\": \"#this\" }, \"score\": \"playerid\" }\n  }}\n}\nTo use it in a function, you can do that following\nscoreboard players operation #this playerid = @s playerid\nsay @e[predicate=namespace:match_id] HAVE THE SAME PLAYERID\n","tags":[],"versions":"latest","url":"/guide/player-id-system/"},{"title":"Right Click Detection Summary","content":"\nRight Click Detection Summary\n\nGet more information on specific methods by going to the dedicated pages:\n\nCOAS\nFood\nEoE\nInteraction\n\nWarped Fungus on a Stick (WFOAS)/Carrot on a Stick (COAS)\n\nThis method works by using an item.used scoreboard objective which triggers when using either of the two items and then running commands as/at players with a score of 1 or higher.\nPros:\n\neasy to pull off\nworks in any world\ndoesn't require additional entities\nCons:\nwfoas attracts striders/coas pigs and rabbit\nDepends:\ndetects up to 5 clicks/second when holding right click\n\nFood component\n\nThis method works by using an item with a very long eating time which will never finish, in combination with an advancement to detect when you begin eating it.\nPros:\n\ncan detect clicks from any item\nworks in any world\ndoesn't require additional entities\ndoesn't need to run every tick\ndoesn't attract mobs\nCons:\nonly works in 1.20.5+\nslows player down when holding right click\nDepends:\ndetects up to 20 clicks/second when holding right click\nbound to the player, not a specific location\n\nEye of Ender (EoE)\n\nThis method works by using an advancement to detect whenever a player uses an eye of ender and then executing code as/at them.\nPros:\n\ndoesn't require additional entities\ndoesn't attract mobs\ndoesn't need to run every tick\nCons:\nslows player down when holding right click\nonly works in worlds without strongholds (there are ways to work around this, although these are way less performant)\nDepends:\ndetects up to 20 clicks/second when holding right click\nbound to the player, not a specific location\n\nInteraction Entities\n\nThis method works by using an advancement to check whether a player interacted with an interaction entity and then executing code\nPros:\n\nsee \"depends\"\ncan also detect left clicks\nCons:\nrequires an additional entity\nDepends:\ndetects up to 5 clicks/second when holding right click\nbound to a specific location, not player\ncan't be interacted through\n","tags":[],"versions":"latest","url":"/guide/right-click/"},{"title":"Right Click Detection (Interaction)","content":"\ninteracted_with_interaction.json (located in the packs advancement folder)\n\n{\n  \"criteria\": {\n    \"requirement\": {\n      \"trigger\": \"minecraft:player_interacted_with_entity\",\n      \"conditions\": {\n        \"entity\": {\n          \"type\": \"minecraft:interaction\"\n        }\n      }\n    }\n  },\n  \"rewards\": {\n    \"function\": \"namespace:rightclick_run\"\n  }\n}\n\nrightclick_run.mcfunction (located in the packs function folder)\n\nannounces the use of the item in chat, feel free to replace this with whatever\nsay Used interaction\nadvancement revoke @s only namespace:interacted_with_interaction\n","tags":[],"versions":"latest","url":"/guide/right-click/interaction/"},{"title":"Right Click Detection (Carrot on a Stick)","content":"\nFor the sake of simplicity the following example will use a coas, if you want to change that you can just carrot_on_a_stick in the load function with warped_fungus_on_a_stick!\n\nload.mcfunction\n\nadds the objective to be usable later on\nscoreboard objectives add rightclick minecraft.used:minecraft.carrot_on_a_stick\n\nmain.mcfunction\n\nruns the \"rightclick_run\" as players who used a coas (you can also specify special item nbt here by using a predicate or using \"execute if data entity @s\", you will still have to reset the score on EVERY click if you don't want the pack to break tho)\nexecute as @a[scores={rightlick=1}] run function namespace:rightclick_run\n\nrightclick_run.mcfunction\n\nannounces the use of the item in chat, feel free to replace this with whatever\nsay Used COAS\nsets the rightclick score to 0 so it can be used again\nscoreboard players set @s rightclick 0\n","tags":[],"versions":"latest","url":"/guide/right-click/coas/"},{"title":"Right Click Detection (Food)","content":"\nThis is an example, so you'll need to change a few things for your actual datapack:\nChange stick to the item you want to detect\nChange namespace to your namespace\nChange custom_stick to whatever custom data you want\nNote: You can use any item for this, but if it has existing right-click functionality (like placing a block), it will keep that.\n\nThis is the command to give you a stick with the custom food component (You can run this in the chat to test it, or put it in a function to trigger when you want):\ngive @s stick[minecraft:food={nutrition:0, saturation:0, can_always_eat:true, eat_seconds:999999999}, minecraft:custom_data={custom_stick:true}]\n\nclick_food.json (located in your pack's advancement folder)\n\n{\n  \"criteria\": {\n    \"requirement\": {\n      \"trigger\": \"minecraft:using_item\",\n      \"conditions\": {\n        \"item\": {\n          \"items\": [\n            \"minecraft:stick\"\n          ],\n          \"predicates\": {\n            \"minecraft:custom_data\": {\"custom_stick\": true}\n          }\n        }\n      }\n    }\n  },\n  \"rewards\": {\n    \"function\": \"namespace:rightclick_run\"\n  }\n}\n\nrightclick_run.mcfunction (located in your pack's function folder)\n\nrevokes the advancement from the player so it can be used again\nadvancement revoke @s only namespace:click_food\n\nannounces the use of the item in chat, feel free to replace this with whatever\nsay I successfully used food component detection!\n\nHow it works\nWe've added a food component to our custom stick item, allowing it to be consumed like food. The player won't actually eat it, since eat_seconds is set to 999999999, so it would take them over 30 years. The food component lets the player try to eat it, which can be detected using an advancement. That advancement runs a function which removes the advancement so it can be triggered again next tick, and runs whatever code you want to the item to trigger.\n","tags":[],"versions":"latest","url":"/guide/right-click/food/"},{"title":"Right Click Detection (Eye of Ender)","content":"\nused_eye_of_ender.json (located in your packs advancement folder, you can also add an nbt tag to the nbt field in items to make this only run when specific eoes are used)\n\n{\n  \"criteria\": {\n    \"requirement\": {\n      \"trigger\": \"minecraft:using_item\",\n      \"conditions\": {\n        \"item\": {\n          \"items\": [\n            \"minecraft:ender_eye\"\n          ]\n        }\n      }\n    }\n  },\n  \"rewards\": {\n    \"function\": \"namespace:rightclick_run\"\n  }\n}\n\nrightclick_run (located in your packs function folder)\n\nannounces the use of the item in chat, feel free to replace this with whatever\nsay Used eoe\nrevokes the advancement from the player so it can be used again\nadvancement revoke @s only namespace:used_eye_of_ender\n\nIf you want this method to work in worlds with strongholds, you can either block the target of ender eyes in the pack.mcmeta or killing the eye and giving it back after it being used.\n","tags":[],"versions":"latest","url":"/guide/right-click/eoe/"},{"title":"Getting Started","content":"\nThis page is validated and up to date with Minecraft Java: 1.21\n\nGetting Started\nIf you're new to datapacks, you're at the right place. Looking around, getting into datapack creation might seem confusing, but once you've grasped the basics, you'll be off to a good start!\n\nIf you don't know what datapacks are, then take this explanation. Datapacks are essentially add-ons to Minecraft which can change the game, whether by adding a simple game mechanic, or creating completely new experiences! The best part is that they're really easy to create, even if you have little coding knowledge\n\nThis guide will help you to create your first datapack, whether you've never tried coding before or if you've got loads of experience. The process of coding a datapack is a bit different to other typical programs. By the end of this tutorial, you'll have made a simple datapack which makes arrows explode when they land!\n\nGetting Started - Setting up an empty datapack\n\n\nThe first step when creating a datapack is to make a new world to test it in. Go ahead and do that now - make sure that your world has cheats enabled and it is set to creative mode. Once you've created the world, the next step is to find and open your world folder:\nSave and quit your world\nGo to your world in the Singleplayer menu and hit \"Edit\"\nPress \"Open World Folder\"\n\nThis folder opens contains all the data in your Minecraft world. You should see that there's lots of other subfolders in this folder. Find the one which is called datapacks, and open it.\n\nThis folder is where the world's datapacks are stored. Create a folder - this will be the root folder of your datapack project. The name doesn't matter. I'm just going to call it Example Datapack. Open this new folder. Inside this folder is where all the data starts from.\n\nBefore we go further, if you have downloaded and installed Visual Studio Code and the relevant extensions, then you should be able to right click inside the new folder that you created and \"Open in Code\". If not, then no worries, it isn't required.\n\nThe first file we want to create is the pack.mcmeta file. This file will tell Minecraft that the folder is a datapack, as well as holding the basic information of the pack. Create pack.mcmeta, and put this inside it:\n{\n    \"pack\":{\n        \"description\":\"DATAPACK NAME HERE\",\n        \"pack_format\":48\n    }\n}\nIf you're interested, here's what this file means:\npack is an object containing the metadata of the file.\n  description is the name of your datapack, usually along with a short description of what your pack does.\n  pack_format tells Minecraft what versions this datapack works in. 48 is the latest for 1.21\n\nWriting your first function\nWhat are functions? In short, functions are the majority of what makes up most datapacks. A function is a file containing Minecraft commands. When a function is ran, every command in the function is ran in order. Functions are always ran as an entity (or as the Server) and at a position\nLet's get started by writing one simple function. In traditional programming function, let's make a function to show you \"Hello World\" when it is ran.\n\nCreate a folder in your datapack called data.\nIn the data folder, create a new folder.\nThis folder is your namespace - it will contain all the data specific to your datapack. Usually this needs to have a unique name (one which other people would not have picked), but for this tutorial just call it example.\nIn the example folder, create a folder called function. This folder will contain all the mcfunction files.\n\nYou should now have a folder structure that looks something like this:\n/world/datapacks/Example Datapack/data/example/function\nIn versions earlier than 1.21, the function folder should be called functions, due to some pesky name changes Mojang introduced in a recent update.\n\nOnce you're sure that's correct, you can start writing the actual function.\n\nIn the function folder, create an empty file called hello_world.mcfunction. Open this file with any text editor (we reccomend Visual Studio Code)\n\nInside hello_world.mcfunction, put the following:\nShow the player Hello World on their screen\ntitle @s title \"Hello World!\"\n\nGive the player a diamond\ngive @s diamond\nIt's that simple! Once you save that file, rejoin your world and then run /reload, you should be able to use the following command to run the function:\n/function example:hello_world\n\nWhat's next?\nNow you know how to create a basic function and run it, we'll next start to think about how to create our project. For more advanced projects, this can sometimes be the most difficult part. Luckily for us, what we want to create won't be too difficult.\n\nLet's break down the idea into smaller steps. Remember, we want to create a datapack which makes arrows explode.\n\nDetect when an arrow lands on the ground. We can do this by running a command on a loop which will select any arrow on the ground and then run a function.\nCreate an explosion. This is as simple as summoning a TNT at the position of the arrow.\nRemove the arrow. If you don't do this, then it will keep on exploding forever.\n\nThe next steps of this guide will guide you through the typical process of each of those steps.\n\nRunning functions on a loop\nThe first step on our list is to detect arrows which land on the ground. To do this, we need to run a command on a loop. Luckily, Minecraft makes this pretty easy for us.\n\nFirstly, let's make the function which you want to run on a loop. In the function folder, create a new mcfunction file - call this one loop.mcfunction.\n\nFor now, let's just make it say \"Hi\" every time it loops. You can do this by putting this in the new function:\nsay Hi\n\nTo make this function run on a loop, we need to create a JSON file which tells Minecraft \"run this command every tick\" (every tick = 20 times per second)\n\nIn the data folder, create the minecraft folder.\nIn the minecraft folder, create a tags folder\nIn the tags folder, create a function folder\nIn the new function folder, create a new file: tick.json\n\ntick.json is NOT a function. In tick.json, we are going to put a list of functions which we want to run every tick. If you put any commands in tick.json, it will break your pack.\n\nIn tick.json, put the following:\n{\n    \"values\":[\n        \"example:loop\"\n    ]\n}\nvalues is a list of function references which will be run on a loop.\nexample:loop is a reference to the loop.mcfunction file we created earlier. example refers to the namespace (the folder in data), and loop refers to the mcfunction file name.\n\nIf you save this file, go back to your world, and run /reload, you should see that the chat is being spammed with \"Hi\" over and over again!\n\nThis guide goes up to the end of section \"[​1] Running functions in a loop\" in the original PMC guide. Feel free to continue writing it, but do not copy all of it over since much could be rewritten.","tags":[],"versions":"latest","url":"/guide/getting-started/"},{"title":"Raycasts","content":"\nRaycasting\n\nRaycasting is when we shoot a line from the player's eyes in the direction they are looking. We use this to get what the player is looking at, and do something to it, such as spawning an explosion.\n\n&gt; This tutorial uses a neat thing called a recursive function. A recursive function is a function which runs itself over and over again.\n\nRaycast to an entity\n\nThis method will show you how to find what entity that a player is looking at. This is useful for many reasons - if you wanted to make a gun datapack, you'd need to damage the entity that a player is looking at in order to damage them.\n\nTo do this, you have to run a recursive function which will start at the eyes of the player and keep running itself 0.1 blocks forward until it hits an entity. When it does hit an entity, you can easily get the entity and do something to it.\n\nFirstly, we'll make the function which, when you run it, will start the raycast. In this function, we'll want to:\n\nset the maximum distance for the raycast, so it won't go on forever if it never hits an entity.\nrun the function at the eyes of the player\n\nTo set a maximum distance, we store the maximum amount of times we want the function to run in a scoreboard. Every time the recursive function runs, we want to subtract one from that scoreboard, and only continue if the score is more than 0.\n\nFirstly, you need to create a scoreboard. This should go in your /reload function.\n\nscoreboard objectives add raycast_temp dummy\n\nThen, we can use this scoreboard to set the limit of the raycast before we run it.\n\ntag @s add raycaster\n\nSet the distance limit on the raycast. (10 x limit in blocks, so 1000 would be 100 blocks)\nscoreboard players set .limit raycast_temp 1000\n\nStart the raycast\nexecute at @s anchored eyes positioned ^ ^ ^.1 run function :raycast\n\ntag @s remove raycaster\n\nThe raycaster tag is used to make sure that the raycast doesn't hit the player who ran it. In the raycast, we check for any entity at the current position which doesn't match the tag.\n\nIn the raycast function, we want to check if the function has hit an entity, and if not, run it again until it does, moving a bit forward each time:\n\nRemove one from the limit\nscoreboard players remove .limit  1\n\nOptional - place a particle, to make the raycast leave a trail\nparticle minecraft:dust 1 0 0 1   ~\n\nIf the raycast has hit an entity, make it say hi\nexecute as @e[dx=0,tag=!raycaster] run say hi\n\nIf the raycast hasn't hit an entity, continue, but only if the limit is 1 or more (1..)\nexecute if block   ~ #minecraft:replaceable unless entity @e[dx=0,tag=!raycaster] positioned ^ ^ ^0.1 if score .limit  matches 1.. run function :raycast\n","tags":[],"versions":"latest","url":"/guide/raycasts/"},{"title":"Debugging your Datapacks","content":"\nDebugging your datapacks\n\nThere will come times when your datapack won't work, and you will have to figure out what exactly doesn't work in it. Don't worry if this happens to you, if you're like any of the rest of us, this will happen often. Code will almost never work the first time you try it. An error in your code is referred to as a bug. Removing these bugs is called debugging. This guide will teach you the best methods for debugging datapacks.\n\nWhat are bugs?\nBugs are a fancy programmer term for an error in your code. There are two main types of bugs:\nSyntax error**: This is a bug in the actual written code. This is caused by the code you write being incorrectly written so that the computer literally can't read it. For example, writing \"executr as @a\" would be a syntax error because \"executr\" isn't a command.\nLogic error**: This is a bug where the written code is correctly written, but the code doesn't do what you want it to. This is caused by a mistake in the code logic. In the simplest example, if you want to give a player 32 diamonds, but you accidentally wrote 322.\n\nFinding and debugging syntax errors\nSyntax errors are pretty easy to spot and fix, due to Minecraft's output logs, which literally tell you if your code is incorrect. When you're coding datapacks, its a good idea to always have the logs open if you need to double check it. You can open the logs by opening the default Minecarft launcher and clicking \"Settings\", and then enabling \"Open output log when Minecraft: Java Edition starts\", then just starting the game.\n\nImage of a guide on how to open the Minecraft launchers output logs\n\nSyntax errors will show up in red text when you /reload your datapack. But sometimes other errors can also show in yellow text instead.\n\nLets take this image as an example:\nImage of an output log with an error.\nHere, the error tells you exactly where the error is - in this case it's in the function \"be:give\" at line 1 after \".... give @s\". And indeed I did spell \"loot\" as \"lot\", which caused the error.\nImage of the code with the syntax error\n\nFinding logic errors\nLogic errors are more difficult to find because there's nothing actually incorrect with the code you wrote, it just does something other than what you want it to do.\n\nAn easy way to find where a logic error is in the code is to make use of the say or tellraw command. These commands will send any message to the chat, making it easy for you to know when and if your code actually runs as you expect it to. You can easily put a say Function  ran correctly command in your function - If the function runs, then it will send a message to the chat. It will also send the name of the entity that ran the function to the chat, so you can see if your function is executed by the correct entity.\n\nSimilarly, you can use the tellraw command for more advanced debugging. The tellraw command also has the capability to show you the value of scoreboards and NBT values, so you can check what data your code is using. For instance, if you want to check the value of a scoreboard, you could use the following command:\ntellraw @a {\"score\":{\"name\":\"@s\",\"objective\":\"some_scoreboard_objective\"}}\n\nBased on the output of these commands in chat, you can use this to tell where your code goes wrong. (Just make sure to remove them after you've found the error, otherwise it can get annoying).\n\nThough you might sometimes want to keep the debug messages in the datapack, but you don't want it to be sent to every player. Fortunately for us, with the tellraw command, you can specify to who the message will be sent. Meaning, you can only send the debug messages to those, who have the tag debug:\ntellraw @a[tag=debug] {\"text\":\"Debug message sent only to people with the debug tag!\"}\n\nDebugging logic errors\nUnfortunately, debugging logic errors in your code isn't as easy as fixing one spelling mistake. But yet there are still techniques that we can use.\n\nOne way to solve logic errors is to recreate the error in a separate project. When you remove all the other context of the pack, you can focus just on the bit which doesn't work. You can just copy out the code you want to fix into a separate datapack, then fix it there. Once you've identified and fixed the problem, you'll know how to fix it in the real project.\n\nSummary\nThe first main method for debugging datapacks is using Minecrafts output logs, we've already learnt how to use those in the first part of this guide. The second method is using the in-game commands, like /say and /tellraw to print information in real-time about how your datapack works. But those are not the only ones, you can use the /scoreboard objectives setdisplay  command to show the values of a scoreboard on your screen in real-time, or you can use /data get ..., which will print the value of any NBT data in chat.\n\nAn image of a scoreboard on screen\n\nYou might also find that some other methods that suit you the best, for example you might find the Data Reload mod useful for displaying errors in chat, or a completely different method, that is up to you.\n\nThanks for reading!\nYou made it to the end! Hopefully you now know how to debug your datapacks, but if you ever get stuck, want help or just want to improve, please join our super friendly Discord community: https://discord.datapackhub.net/. We've got teams of people waiting to help you with any questions or projects you may have!","tags":[],"versions":"latest","url":"/guide/debugging-datapacks/"},{"title":"Adding Jukebox Songs","content":"\nThis page is validated and up to date with Minecraft Java: 1.21\n\nHow to add custom jukebox songs\nIn this guide, we will not only learn how to create custom jukebox songs, but also how to give yourself a custom music disc item and implement custom sounds!\n\nThis will only work in 1.21+, as custom enchantments were added in the snapshot 24w21a.\nThis guide requires you to have atleast a small understanding of datapacks, if you don't understand this guide, you can read the Getting Started guide.\n\nSetting up the datapack\nTo start you will need a basic datapack, if you don't know how to make one, see the Getting Started guide.\n\nFirstly, we are going to create the actual jukebox song file in the directory data//jukebox_song/. The file can be named whatever, but it has to be in the .json file format. For the purposes of this tutorial, we're gonna call it example_jukebox_song.json. Inside, we will put and configure this:\n\n{\n    \"comparator_output\": 13,\n    \"description\": {\n        \"text\": \"ARTIST - SONG NAME\"\n    },\n    \"length_in_seconds\": 69.0,\n    \"sound_event\": {\n        \"sound_id\": \":\"\n    }\n}\n\nThis is a run-down of the fields in that file:\ncomparator_output: A value between 1 and 15, representing the redstone output when a comparator is placed next to the jukebox playing this song.\ndescription: The description of the enchantment (should be a JSON text component).\nlength_in_seconds: The length of the song (in seconds)\nsound_event: The ID of the sound (from the resourcepack) to play.\n\nIf you don't understand what to put in sound_event, dont worry, the next part is going to focus specifically on this!\n\nAdding custom music - Resourcepack\nThis part is going to be optional in the case, that you only want a vanila Minecraft sound to play from the jukebox. In that case, change the sound_id in the example_jukebox_song.json file from the datapack to the sounds ID. (for example: \"sound_id\": \"minecraft:music_disc.cat\").\n\nIf you don't want to use a default Minecarft sound, then a resource pack is required to add the custom sound (in this case, the music on the disc) to Minecraft, so that the datapack can read it.\n\n&lt;Info&gt;Minecraft handles sound in .ogg files. There are many different converters you can use to convert an MP3, WAV, or other audio file to .ogg.&lt;/Info&gt;\n\nYou need to add your .ogg file (the audio of your music disc) to assets/&lt;namespace&gt;/sounds/&lt;title&gt;.ogg. Make sure that &lt;namespace&gt; and &lt;title&gt; are the same values you put in the datapack's JSON file (the example_jukebox_song.json file in our case).\n\nThen, if you haven't already, you need to create a sounds.json file at the position assets/&lt;namespace&gt;/sounds.json. This file tells Minecraft what audio files map to what IDs. Put this inside:\n{\n    \"music_disc.&lt;title&gt;\": {\n        \"sounds\": [\n            {\n                \"name\": \"&lt;namespace&gt;:&lt;title&gt;\",\n                \"stream\": true\n            }\n        ]\n    }\n}\n\nSee it in action\nOnce you save the above files, you need to activate the resource pack, and reload it with the keybind F3 + T in-game. You will also need to leave and rejoin the world to update the datapack.\n\n&lt;Warning&gt;For this to work, you will need to leave and rejoin the world, just using the /reload command won't do the trick here!&lt;/Warning&gt;\n\nTo get the music disc, you need to get an item which has the minecraft:jukebox_playable component. This can be any item - it doesn't have to necessarily be an already existing music disc (but you can if you want)\ngive @s minecraft:YOUR_ITEM[minecraft:jukebox_playable={song:\"&lt;datapack namespace&gt;:example_jukebox_song\"}]\n\nThen, you can use this item on a jukebox, and it should start playing your song!","tags":[],"versions":"latest","url":"/guide/jukebox-songs/"},{"title":"Generating Random Numbers","content":"\nGenerating Random Numbers (1.20.2 and below)\n\n⚠️ This is only a viable way of doing this in versions older than 1.20.2. If you are using 1.20.2 or higher, you can just use /random!\n\nGenerating a random number is very useful in programming for a variety of reasons, and this is the best way to do it in a Datapack.  Put this in data//loot_tables/rng.json:\n\n{\n  \"pools\": [\n    {\n      \"rolls\": {\n        \"min\": 1,\n        \"max\": 10\n      },\n      \"entries\": [\n        {\n          \"type\": \"minecraft:item\",\n          \"name\": \"minecraft:stone\",\n          \"functions\": [\n            {\n              \"function\": \"minecraft:set_count\",\n              \"count\": 0\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}\n\nYou can change the values 1 and 10 to change the range. If you leave it as it is, it generates a random number between 1-10.  To use this, you just have to store the result of summoning this loot table:execute store result . . . run loot spawn   ~ loot :rngThis will store the random number in wherever you specified.\n","tags":[],"versions":"latest","url":"/guide/random-number-old/"},{"title":"Custom Item","content":"\n⚠️ This Guide is deprecated as of version 1.20.5\n\nThis guide assumes that you already knowledge some basic commands and how crafting recipes and advancements work.\n\nText in between &lt;&gt; is a placeholder\n\nTo create a crafting recipe for one of your custom items, you need just a little bit more than for a normal recipe.\n\nBecause of the fact that you can't use nbt in a recipe, we need a small workaround.\n\nLets add the recipe first:\n\n&gt; rocket.json\n{\n    \"type\": \"minecraft:crafting_shaped\",\n    \"pattern\": [\n        \" I \",\n        \" I \",\n        \"O O\"\n    ],\n    \"key\": {\n        \"I\": {\n            \"item\": \"minecraft:iron_block\"\n        },\n        \"O\": {\n            \"item\": \"minecraft:obsidian\"\n        }\n    },\n    \"result\": {\n        \"item\": \"minecraft:knowledge_book\"\n    }\n}\n\nAs mentioned before, we can't use the custom item as output, so we use a knowledge book as a placeholder.\n\nTo switch the knowledge book with our custom item, we need an advancement to react when we craft the recipe. For this we use the recipe_crafted trigger.\nWith some trickery it is also possible to make the ingredients require certain nbt.\n\n&gt; craft_rocket.json\n{\n    \"criteria\": {\n        \"requirement\": {\n            \"trigger\": \"minecraft:recipe_crafted\",\n            \"conditions\": {\n                \"recipe_id\": \":rocket\"\n            }\n        }\n    },\n    \"rewards\": {\n        \"function\": \":craft_rocket\"\n    }\n}\n\nLast but not least we have to make the function that handles the item switching.\nYou can either use a give command or, what I recommend more, define the item in a separate loot table and use the loot command.\n\n&gt; craft_rocket.mcfunction\nclear @s knowledge_book\nloot give @s loot :\nadvancement revoke @s only :craft_rocket\n\nThis is all you need to create a crafting recipe for your custom items.\n","tags":[],"versions":"latest","url":"/guide/custom-item-old/"},{"title":"Installing a Datapack","content":"\nIntroduction\n\nSo you've found a nice datapack for Minecraft, and the next step is to get it into your game. This guide will explain how to install a datapack onto a world which exists, a new world.\n\nInstalling a datapack to an existing world\n\nIn your world menu, find the world which you want to install the datapack on. Click Edit.\n   The singleplayer menu\nOpen the world folder.\n   The edit menu\nIn the world folder, open the datapacks folder.\n   World folder with datapacks highlighted\nPut the datapack zip file into the folder.\n   zip folder in datapacks folder\nIf the zip folder contains a folder which contains data and pack.mcmeta, then put that folder in the datapacks folder instead of the full zip. Putting the zip in the datapacks folder only works when data and pack.mcmeta are directly in the root folder of the zip.\nRejoin the world and run /reload.\n   Reload command in chat\n\nInstalling a datapack to an new world\n\nGo to the Create New World screen. Make sure that you enable cheats.\n   Create new world screen\nNavigate to the Data Packs screen. This is under the \"More\" tab in the latest versions.\n   The Data Packs screen option\nDrag and drop the datapack zip into this screen.\n   The Data Packs screen after I dragged and dropped something in\nIf it doesn't show up, then it's likely that the zip file contains a folder which contains the datapack, and not the zip file just containing the datapack. You need to take the folder out of the datapack, and put it in the datapacks folder (click the Open Packs Folder button to open it.)\nClick on the datapack icon to apply it to the world\n   The Data Packs screen after I clicked the icon\nCreate the world, and then run /reload in chat.\n   Reload command in chat\n\nInstalling a datapack to a realm\n\nTo install a datapack to a realm, you need to basically do this:\n\nDownload the world from the realm into your singleplayer worlds.\nFollow the steps in \"Installing a datapack to an existing world\" to install a datapack on that world\nUpload that world to your realm.\n","tags":[],"versions":"latest","url":"/guide/installing-a-datapack/"},{"title":"Creating a Datapack","content":"\nHello there, traveller!\n\nCreating a Minecraft Datapack is an easy way to change something in Minecraft. If you've ever done anything with Minecraft commands or command blocks, then it's very simple.\nIf you don't know what datapacks are, then take this explanation. Datapacks are essentially add-ons to Minecraft which can change the game, whether by adding a simple game mechanic, or creating completely new experiences! The best part is that they're really easy to create, even if you have little coding knowledge.\n\nThis guide will help you to create your first datapack, whether you've never tried coding before or if you've got loads of experience. The process of coding a datapack is a bit different to other typical programs. By the end of this tutorial, you'll have made a simple datapack which makes arrows explode when they land! Pay close attention, because some of this will be a bit difficult if you're new to making datapacks. If you need any help, please join our Discord server.\n\nfinished product\n\nGetting Started - setting up the empty datapack folder\n\nLearn: How to create an empty datapack\n\nThe first step when creating a datapack is to make a new world to test it in. Go ahead and do that now. Once you've created the world, the next step is to find and open your world folder. Getting to the world folder is pretty simple:\n\nLeave your world\nGo to your world in Minecraft and hit \"Edit\"\nPress \"Open World Folder\"\n\nThis folder opens contains all the data in your Minecraft world. You should see that there's lots of other subfolders in this folder. Find the one which is called datapacks, and open it.\n\nworld folder\n\nThis folder is where the world's datapacks are stored. Open this and create a folder - this is the root folder of your datapack project. The name doesn't matter for now. I'm just going to call it Example Datapack.\nUnlike mods, datapacks are essentially just folders containing more folders. This is called a folder structure. The root folder is the folder at the top of the structure - in this case, the folder we just created now. Subfolders are the name given to a folder inside another folder. Any folders we make under the root folder are subfolders of the root folder.\n\nOpen the folder you just made. By the end, this folder is going to contain three things - the pack.mcmeta file (this tells Minecraft that it is a datapack), the pack.png (the project's icon), and the data folder (which contains all the code and features of your datapack - hence the name!).\n\nBefore we go further, if you have downloaded and installed Visual Studio Code and the relevant extensions, then you should be able to right click and \"Open in Code\". If not, then no worries, it isn't required.\n\nWe first need to create the pack.mcmeta file. Go ahead and create a new empty file, and name it pack.mcmeta. In this file, you put the description and version of your pack:\n\n{\n\t\"pack\": {\n\t\t\"description\": \"Float when you sneak\",\n\t\t\"pack_format\": 18\n\t}\n}\n\nHere's the run-down of what this all means:\n\ndescription: This is a short description of what your pack does. Here, you should put the name of your datapack, your name, and a very short description. This description will be shown in the datapack viewer.\npack_format: This represents the version that your project supports. You can find the list of pack_format values here. 18 is 1.20.2.\n\nWriting your first function\n\nLearn: How to create and use functions\nFirst, a brief explanation. Most datapacks will mostly consist of functions, stored in mcfunction files (such as example.mcfunction). Functions are essentially just lists of commands (such as /give, /summon, etc) which are all ran at once in order.\nWhen you run a function, it is always run as a mob/entity (or the game) and at a position/rotation. If your function places a block, it will place a block at the position the function is run at.\n\nWe'll get started by writing a simple function. In traditional programming fashion, let's make a function to show you \"Hello World\" when it is run.\n\nOpen the data folder\nInside the data folder, create a new folder. This is the namespace of your datapack. You can give it any name as long as it has no capital letters or spaces, but for the purposes of this tutorial we're going to call it example.\nOpen the example folder and create a new folder called functions. This folder will contain all the .mcfunction files which make up the body of your datapack. Open that folder.\n\nThe path of the folder you have open should be: /world/datapacks/Example Datapack/data/example/functions\n\nOnce you've done that, we can finally get started creating the function. Create a new empty file, and name it hello_world.mcfunction. Open it with any text editor (we recommend VS code - see the top of this article).\n\nInside the function, put this:\n\nShow the player Hello World on their screen\ntitle @s title \"Hello World!\"\n\nGive the player a diamond\ngive @s diamond\nYou may notice that title and give are actually just normal minecraft commands - you could run these in chat and it would do the same thing as this function. That's all datapacks are, just lists of commands. The lines which start with # are comments - the game ignores these lines, so we can write useful comments there.\n\nIt's that simple! Once you save that file and then join your minecraft world if you haven't already, then you can run /reload to, well, reload the data pack. Then, in chat, run /function example:hello_world to see it in action!\n\nSo, what's next?\n\nNow you know how to create a basic function and run it, we'll next start to think about how to create our project. For more advanced projects, this can sometimes be the most difficult part. Luckily for us, what we want to create won't be too difficult.\n\nLet's break down the project into smaller steps. (In computer science, this is called decomposition).\n\nDetect when an arrow lands on the ground. We can do this by running a simple operation on a loop which selects all arrows in the world, but only if they are in the ground.\nIf an arrow is in the ground, make an explosion. We can do this by summoning a TNT block.\nRemove the arrow so it only explodes once.\n\nRunning functions on a loop\n\nThe first step on our to-do list is to detect arrows which have landed on the ground. To do this, we're going to have to run a command on loop which will select all arrows which are in the ground. Luckily, Minecraft makes looping commands very easy.\n\nFirst, let's make the function which we want to run on a loop. In your functions folder, create a new function - call it loop.mcfunction. For now, let's make this function say \"Hi\" when it's ran. The contents of the function should be just this:\n\nsay Hi\n\nAfter you've done that, we're going to need to create some more folders. Pay attention here, because this is where some people mess up.\n\nIn data, create another folder. Call this one minecraft, all lower case.\nIn the new minecraft folder, create a tags folder.\nIn the new tags folder, create a functions folder.\nFinally, create a new file: tick.json.\n   In the new tick.json file, we're going to put a list of files which we want to run on a loop. More specifically, every game tick, which is 20 times per second. We only want one function to run on a loop, so just put this in tick.json:\n\n{\n\t\"values\": [\"example:loop\"]\n}\n\nHere, example is the name of your namespace - the folder in data which contains the functions folder. (/data/example/functions/loop.mcfunction). loop is just the name of your function without the .mcfunction at the end.\n\nIf you save this file, go back to your world, and run /reload, you should see that the chat is being spammed with \"Hi\" over and over again!\n\nFinding the arrows\n\nNow we've created a function which will run infinitely on a loop, we can move on to detecting when an arrow is in the ground.\n\nAs far as the game is concerned, an arrow is an entity, just like a pig, cow, zombie, skeleton, or anything else like that. In our code, we can select entities which match a set of criteria, and then run commands as the entity. Selecting an entity is basically like finding any entity which matches a set of criteria, and then doing something to it. We're going to want to select all arrow entities which are in the ground.\n\nThe selector to do that is as follows: @e[type=arrow,nbt={inGround:1b}]. Click for a guide to how selectors work.\n\nUsing a selector, we can run an execute command which will run a command as any entity which matches the selector.\n\nexecute as @e[type=arrow,nbt={inGround:1b}] at @s run say I'm an arrow, I'm in the ground!\n\nIf you put this command in your loop.mcfunction (remove the other command, since we don't need that any more), then save and reload, you can then fire an arrow onto the ground. You should see that the arrow says \"I'm an arrow, I'm in the ground!\"\n\narrow in ground\n\nMake it go boom\n\nThis is the fun part! We've made a simple system which will select all arrows in the ground, and run a command as those arrows. From here, it isn't too hard to make it explode. We can split the last section up into two parts:\n\nMake an explosion\nRemove the arrow, so it only explodes once.\n\nFirstly, we can remove the old command in loop.mcfunction which makes the arrow say it's an arrow and that it's in the ground. Replace it with the commands to spawn a TNT entity as the arrow, and then remove the entity, as follows:\n\nSummon a TNT at any arrow in the ground.\nexecute as @e[type=arrow,nbt={inGround:1b}] at @s run summon tnt\n\nRemove any arrow in the ground\nkill @e[type=arrow,nbt={inGround:1b}]\nThe at @s in the commands above make sure that the command is ran at the position of the arrow, otherwise it would run as the arrow, but at the world spawn.\n\nAnd, that's it! You're done! If you put that in loop.mcfunction and save, /reload, and join your world, then you can fire an arrow. If all goes well then it should explode when it lands.\n","tags":[],"versions":"latest","url":"/guide/creating-a-datapack/"},{"title":"Site Development","content":"\nSite Meta and Contribution\nThis page is meant to be an introduction for contributors to the wiki. In it is multiple examples which you can examine raw in the site source code.\n\nContributing\nThe full contributing guide is available on a separate page here.\n\nTo contribute, please fork the Datapack-Hub/wiki repo on GitHub, make changes in your fork, then submit a pull request, explaining your changes.\n\nFormatting\nThis section goes over how to format wiki pages. We like consistency, so please read carefully and use these features to your advantage:\nBasic formatting\n\nAll content on the website (other than navbar, sidebar and things that are not the actual wiki pages) are made using a technology called mdsvex. This technology enables people like you to insert markdown with svelte components.\n\nEach page is made of 3 parts:\n\nfront matter (metadata about the page such as title)\ncontent (the actual content of the page)\ncomponents (custom components that allow for interactivity or other features not able to be reproduced with markdown)\n\nEach is crucial to making the page look and feel how it does.\n\nFormatting Examples\n\n\n\nExample Markdown used on the wiki:\nHeading 1\nParagraph text under heading 1\n\nHeading 2\nParagraph text under heading 2\n\nHeading 3\nParagraph text under heading 3\n\nClick the link to go to the main page\n\nI have some inline code for you. Here's some more:\n\n\\{\n    \"this.is\":\"cool!\"\n}\n\\\nList Item\nAnother List Item\n\nFirst List Item\nSecond List Item\n\n| Which page? | How much I hate formatting it? |\n|---|---|\n| This one | Very much |\n| Other ones | Not as much |\n\nCustom Elements\nI am a very important piece of information. In this box, you might find educational info, or explanations for features.\n\nThe stuff in this box is probably very important. You should read this box - it might contain information which affects your datapack.\n\nYou can do this really cool thing. It'll make your life a lot easier! But don't worry - it's only optional.\n\nThis page is validated and up to date with Minecraft Java: 1.21\n\n\n\nResult of the markdown:\n\nHeading 1\nParagraph text under heading 1\n\nHeading 2\nParagraph text under heading 2\n\nHeading 3\nParagraph text under heading 3\n\nClick the link to go to the main page\n\nI have some inline code for you. Here's some more:\n\n{\n    \"this.is\":\"cool!\"\n}\n\nList Item\nAnother List Item\n\nFirst List Item\nSecond List Item\n\n| Which page? | How much I hate formatting it? |\n|---|---|\n| This one | Very much |\n| Other ones | Not as much |\n\nCustom Elements\nI am a very important piece of information. In this box, you might find educational info, or explanations for features.\n\nThe stuff in this box is probably very important. You should read this box - it might contain information which affects your datapack.\n\nYou can do this really cool thing. It'll make your life a lot easier! But don't worry - it's only optional.\n\nThis page is validated and up to date with Minecraft Java: 1.21\n\n\n","tags":[],"versions":"latest","url":"/contribute/"},{"title":"Resources","content":"\nResources\nListed here are links to credible and reliable places to aid in command support and creation.\n\nDatapack Hub\nDiscord\n\nMCStacker\nWebsite\nDiscord\n\nData Pack Generators\nWebsite\n\n","tags":[],"versions":"latest","url":"/resources/"},{"title":"Credits","content":"\nCredits\nThe Datapack Wiki is managed by Datapack Hub, based on an original design and idea by Aandeel. All of the content on this wiki is made possible thanks to the dedication of our awesome contributors! You can contribute to this wiki on our GitHub - click the Edit button on any page.\n\nAdministrators\nThese people run and develop the site, making any and all important decisions.\nSilabear\nCobblestone\nAandeel\n\nEditors\nThese people are in charge of what contributions are added to the site, as well as planning and writing new pages.\nGears\n\nContributors\nThese people have written or edited pages for the wiki or guides.\nDiamond\nHeDeAn\n\nIf you're contributing, feel free to add your username to this page! You can contribute by clicking the Edit button on any page.","tags":[],"versions":"latest","url":"/credits/"}]