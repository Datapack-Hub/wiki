---
title: Slowcast
description: "Like a raycast but in slow. Usefull if simply using tp every tick skips over too much when making it fast."
---

<script lang="ts">
import {LatestPackFormat} from '$lib/reusables';
</script>

# Slowcasting

A Slowcast is similar to a raycast, but unlike a standard Raycast, it is not instant.

In some cases it is enough to use a simple tp command that teleports a marker a bit forward every tick.
If you wanted it to move faster however, you have to increase the distance it telepots and this could result in skipping over entities or blocks you might want to detect.

A slowcast solves this problem by teleporting multiple times within a single tick to travel fastre but still chekcing if it hits something on its way.

:::info
This tutorial uses a thing called a ___recursive function___. A recursive function is a function which runs itself over and over again.
:::

## Slowcasting to an entity

This method shows you how you can create and shoot a slowcast to detect entities on its way.

Slowcasts can be usefull if you want to create fast but not instantantaneous moving projectiles for magic spells for example.

To make a slowcast, you need:
- set up a projectile with all the data it needs
- a duration function to manage the travel distance
- a step function that teleports the projectile and checks if it hit something
- a temporary loop that calls the step function for all active projectiles.

Let's start by creating all the neccessary sccoreboards in the load function.
```mcfunction
# namespace:load

scoreboard objectives add temp dummy
scoreboard objectives add slowcast.steps dummy
scoreboard objectives add slowcast.duration dummy
```

Next step is to initialize the projectile. This is done by running the following function as and at the player.
It summons a new marker entity (any other entity works too) and runs the setup function as that entity.
```mcfunction
# namespace:init

execute anchored eyes positioned ^ ^ ^.3 summon minecraft:marker run function <namespace>:setup
```

Sadly it is not possible to add nbt data in th esummon sub-command so we have to add it  in the setup function too.
We will give it a tag tgat marks it as a slowcast projectile.
After that we set all the score it needs to function properly.
In this example you will see that instead of setting the scores directly it copies from temporary scoreboards.
This is so that the values are not hardccoded and can be different for different projectiles without having to create a new setup fucntion for each projectile. At the end we then call the temporary loop function.
```mcfunction
# namespace:setup

tag @s add slowcast

scoreboard players operation @s slowcast.steps = maxSteps temp
scoreboard players operation @s slowcast.duration = duration temp

function <namespace>:temp_tick
```

The projectile is all set up and the loop function is called.
The loop function is the part of this whole system which keeps everything running as long as there are active slowcast projectiles.
```mcfunction
# namespace:temp_tick

execute as @e[type=marker,tag=slowcast,scores={slowcast.duration=1..}] at @s run function <namespace>:duration

execute if entity @n[type=marker,tag=slowcast] run schedule function <namespace>:temp_tick 1t
``` 

Now the actual slowcast logic which handles the movement, travel distance, and hit detextion.

In the looping function the duration function is called, let's make this one first.
This function is responsible for the slowcasts travel distance and calling the step function for the actual movement.
1. decrement the duration score
2. stores the projectiles step count in a temporary scoreboard
3. calls the step function 0.2 blocks further in the facing direction
4. kill the projectile should it have a distance score of below 1 at the end of the function
```mcfunction
# namespace:duration

scoreboard players remove @s slowcast.duration 1

scoreboard players operation steps temp = @s slowcast.steps
execute positioned ^ ^ ^.1 run function <namespace>:step

execute unless score @s slowcastDuration matches 1.. run kill
```

In the called step function we handle the teleportation betwen the current and target position and checking if the projectile has hit something on it's way there.
1. decrement the step score in the temporary scorebard _(we still need the step score stored in the projectile for the next time we call the step fucntion)_
2. make some particles for the visuals (you could replace the oarticle command with another function call that does more complex stuff)
3. execute a command as every entity _(excluding entities with the slowcast tag and players)_ whose hitbox intersects with both [virtual volumes](https://datapack.wiki/wiki/commands/target_selectors#dxdydz-arguments) run the hit function and kill the projectile.
4. tp the projectile to the current position _(until now it only executed the command at this position but is still 0.1 block further back)_
5. execute this function again one 0.1 block step forward should the temporary step counter still be over 1 _(recursion)_
```mcfunction
# namespace:step

scoreboard players remove steps temp 1

particle flame ~ ~ ~ .1 .1 .1 0 1

execute as @e[type=!player,type=!marker,dx=0] positioned ~-.99 ~-.99 ~-.99 if entity @s[dx=0] positioned ~.99 ~.99 ~.99 unless function <namespace>:hit run kill @n[tag=slowcast]

tp ~ ~ ~

execute if score slowcastSteps temp matches 1.. positioned ^ ^ ^.1 run function <namespace>:step
```

The hit function called in the hit detection does whatever you want it to do when hitting an entity.
It could spawn an explosion, apply an effect, or simply deal some damage.
:::tip
When you make the hit function have a successful return value, it will not kill the projectile in the step function. You could use this to make a piercing projectile for example.
:::
